#!/usr/bin/env python3
"""
MCP Client with Flask SSE API and Multi-Session Support
Supports both stdio and SSE-based MCP servers
"""

import asyncio
import json
import logging
import uuid
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, AsyncGenerator
from dataclasses import dataclass, asdict
import threading
from queue import Queue, Empty
import time

from flask import Flask, request, jsonify, Response
from flask_cors import CORS
import requests

# MCP imports
from mcp import ClientSession, StdioServerParameters
from mcp.client.stdio import stdio_client
from mcp.client.sse import sse_client
from mcp.types import (
    CallToolRequest, 
    ListToolsRequest,
    GetPromptRequest,
    ListPromptsRequest,
    ListResourcesRequest,
    GetResourceRequest,
    Tool,
    TextContent,
    ImageContent,
    EmbeddedResource
)

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

@dataclass
class MCPServerConfig:
    """Configuration for MCP server connection"""
    name: str
    type: str  # 'stdio' or 'sse'
    command: Optional[str] = None  # For stdio servers
    args: Optional[List[str]] = None  # For stdio servers
    url: Optional[str] = None  # For SSE servers
    env: Optional[Dict[str, str]] = None

@dataclass
class SessionContext:
    """Context for a user session"""
    session_id: str
    created_at: datetime
    last_activity: datetime
    conversation_history: List[Dict[str, Any]]
    tool_calls: List[Dict[str, Any]]

class MCPClientManager:
    """Manages multiple MCP server connections and sessions"""
    
    def __init__(self):
        self.servers: Dict[str, MCPServerConfig] = {}
        self.clients: Dict[str, ClientSession] = {}
        self.sessions: Dict[str, SessionContext] = {}
        self.event_queues: Dict[str, Queue] = {}
        self.session_timeout = timedelta(hours=1)
        
    def add_server(self, config: MCPServerConfig):
        """Add a new MCP server configuration"""
        self.servers[config.name] = config
        logger.info(f"Added server configuration: {config.name}")
    
    async def connect_to_server(self, server_name: str) -> bool:
        """Connect to a specific MCP server"""
        if server_name not in self.servers:
            raise ValueError(f"Server {server_name} not configured")
        
        config = self.servers[server_name]
        
        try:
            if config.type == 'stdio':
                if not config.command:
                    raise ValueError("Command required for stdio server")
                
                server_params = StdioServerParameters(
                    command=config.command,
                    args=config.args or [],
                    env=config.env or {}
                )
                
                async with stdio_client(server_params) as (read, write):
                    session = ClientSession(read, write)
                    await session.initialize()
                    self.clients[server_name] = session
                    logger.info(f"Connected to stdio server: {server_name}")
                    return True
                    
            elif config.type == 'sse':
                if not config.url:
                    raise ValueError("URL required for SSE server")
                
                async with sse_client(config.url) as (read, write):
                    session = ClientSession(read, write)
                    await session.initialize()
                    self.clients[server_name] = session
                    logger.info(f"Connected to SSE server: {server_name}")
                    return True
            
            else:
                raise ValueError(f"Unsupported server type: {config.type}")
                
        except Exception as e:
            logger.error(f"Failed to connect to server {server_name}: {e}")
            return False
    
    async def get_available_tools(self, server_name: str) -> List[Tool]:
        """Get available tools from a server"""
        if server_name not in self.clients:
            await self.connect_to_server(server_name)
        
        session = self.clients[server_name]
        response = await session.list_tools(ListToolsRequest())
        return response.tools
    
    async def call_tool(self, server_name: str, tool_name: str, arguments: Dict[str, Any], session_id: str) -> Dict[str, Any]:
        """Call a tool on a specific server"""
        if server_name not in self.clients:
            await self.connect_to_server(server_name)
        
        session = self.clients[server_name]
        
        # Send progress update
        self._send_sse_event(session_id, {
            'type': 'tool_call_start',
            'server': server_name,
            'tool': tool_name,
            'arguments': arguments
        })
        
        try:
            request = CallToolRequest(name=tool_name, arguments=arguments)
            response = await session.call_tool(request)
            
            result = {
                'server': server_name,
                'tool': tool_name,
                'success': True,
                'content': []
            }
            
            for content in response.content:
                if isinstance(content, TextContent):
                    result['content'].append({
                        'type': 'text',
                        'text': content.text
                    })
                elif isinstance(content, ImageContent):
                    result['content'].append({
                        'type': 'image',
                        'data': content.data,
                        'mimeType': content.mimeType
                    })
                elif isinstance(content, EmbeddedResource):
                    result['content'].append({
                        'type': 'resource',
                        'resource': asdict(content.resource)
                    })
            
            # Update session context
            if session_id in self.sessions:
                self.sessions[session_id].tool_calls.append({
                    'timestamp': datetime.now().isoformat(),
                    'server': server_name,
                    'tool': tool_name,
                    'arguments': arguments,
                    'result': result
                })
                self.sessions[session_id].last_activity = datetime.now()
            
            # Send completion event
            self._send_sse_event(session_id, {
                'type': 'tool_call_complete',
                'result': result
            })
            
            return result
            
        except Exception as e:
            error_result = {
                'server': server_name,
                'tool': tool_name,
                'success': False,
                'error': str(e)
            }
            
            self._send_sse_event(session_id, {
                'type': 'tool_call_error',
                'error': error_result
            })
            
            return error_result
    
    def create_session(self) -> str:
        """Create a new session"""
        session_id = str(uuid.uuid4())
        self.sessions[session_id] = SessionContext(
            session_id=session_id,
            created_at=datetime.now(),
            last_activity=datetime.now(),
            conversation_history=[],
            tool_calls=[]
        )
        self.event_queues[session_id] = Queue()
        logger.info(f"Created session: {session_id}")
        return session_id
    
    def get_session(self, session_id: str) -> Optional[SessionContext]:
        """Get session context"""
        self._cleanup_expired_sessions()
        return self.sessions.get(session_id)
    
    def add_to_conversation(self, session_id: str, message: Dict[str, Any]):
        """Add message to conversation history"""
        if session_id in self.sessions:
            self.sessions[session_id].conversation_history.append({
                'timestamp': datetime.now().isoformat(),
                **message
            })
            self.sessions[session_id].last_activity = datetime.now()
    
    def _send_sse_event(self, session_id: str, data: Dict[str, Any]):
        """Send SSE event to session"""
        if session_id in self.event_queues:
            event = {
                'timestamp': datetime.now().isoformat(),
                'data': data
            }
            self.event_queues[session_id].put(event)
    
    def get_sse_events(self, session_id: str) -> AsyncGenerator[str, None]:
        """Get SSE events for a session"""
        async def event_generator():
            while session_id in self.event_queues:
                try:
                    event = self.event_queues[session_id].get(timeout=1)
                    yield f"data: {json.dumps(event)}\n\n"
                except Empty:
                    yield f"data: {json.dumps({'type': 'heartbeat'})}\n\n"
                except Exception as e:
                    logger.error(f"Error in SSE stream: {e}")
                    break
        
        return event_generator()
    
    def _cleanup_expired_sessions(self):
        """Clean up expired sessions"""
        current_time = datetime.now()
        expired_sessions = [
            session_id for session_id, session in self.sessions.items()
            if current_time - session.last_activity > self.session_timeout
        ]
        
        for session_id in expired_sessions:
            del self.sessions[session_id]
            if session_id in self.event_queues:
                del self.event_queues[session_id]
            logger.info(f"Cleaned up expired session: {session_id}")

# Initialize Flask app
app = Flask(__name__)
CORS(app)

# Initialize MCP client manager
client_manager = MCPClientManager()

# Configure default servers (can be modified as needed)
default_servers = [
    MCPServerConfig(
        name="filesystem",
        type="stdio",
        command="npx",
        args=["-y", "@modelcontextprotocol/server-filesystem", "/tmp"]
    ),
    MCPServerConfig(
        name="web_search",
        type="stdio", 
        command="npx",
        args=["-y", "@modelcontextprotocol/server-brave-search"]
    )
]

for server in default_servers:
    client_manager.add_server(server)

@app.route('/api/sessions', methods=['POST'])
def create_session():
    """Create a new session"""
    session_id = client_manager.create_session()
    return jsonify({'session_id': session_id})

@app.route('/api/sessions/<session_id>', methods=['GET'])
def get_session_info(session_id):
    """Get session information"""
    session = client_manager.get_session(session_id)
    if not session:
        return jsonify({'error': 'Session not found'}), 404
    
    return jsonify({
        'session_id': session.session_id,
        'created_at': session.created_at.isoformat(),
        'last_activity': session.last_activity.isoformat(),
        'conversation_count': len(session.conversation_history),
        'tool_calls_count': len(session.tool_calls)
    })

@app.route('/api/servers', methods=['GET'])
def list_servers():
    """List configured servers"""
    return jsonify({
        'servers': [
            {
                'name': name,
                'type': config.type,
                'connected': name in client_manager.clients
            }
            for name, config in client_manager.servers.items()
        ]
    })

@app.route('/api/servers/<server_name>/tools', methods=['GET'])
def list_tools(server_name):
    """List tools available on a server"""
    async def get_tools():
        try:
            tools = await client_manager.get_available_tools(server_name)
            return [
                {
                    'name': tool.name,
                    'description': tool.description,
                    'inputSchema': tool.inputSchema
                }
                for tool in tools
            ]
        except Exception as e:
            logger.error(f"Error listing tools: {e}")
            return None
    
    # Run async function in event loop
    loop = asyncio.new_event_loop()
    asyncio.set_event_loop(loop)
    try:
        tools = loop.run_until_complete(get_tools())
        if tools is None:
            return jsonify({'error': 'Failed to list tools'}), 500
        return jsonify({'tools': tools})
    finally:
        loop.close()

@app.route('/api/sessions/<session_id>/query', methods=['POST'])
def handle_query(session_id):
    """Handle a query with automatic tool selection and execution"""
    session = client_manager.get_session(session_id)
    if not session:
        return jsonify({'error': 'Session not found'}), 404
    
    data = request.json
    query = data.get('query', '')
    
    if not query:
        return jsonify({'error': 'Query is required'}), 400
    
    # Add query to conversation
    client_manager.add_to_conversation(session_id, {
        'type': 'user_query',
        'content': query
    })
    
    async def process_query():
        try:
            # Simple query routing logic (can be enhanced with LLM)
            results = []
            
            if 'search' in query.lower() or 'find' in query.lower():
                # Use web search
                if 'web_search' in client_manager.servers:
                    result = await client_manager.call_tool(
                        'web_search', 
                        'brave_web_search',
                        {'query': query},
                        session_id
                    )
                    results.append(result)
            
            if 'file' in query.lower() or 'read' in query.lower():
                # Use filesystem
                if 'filesystem' in client_manager.servers:
                    # Extract file path from query (simple extraction)
                    words = query.split()
                    file_path = None
                    for word in words:
                        if '/' in word or '.' in word:
                            file_path = word
                            break
                    
                    if file_path:
                        result = await client_manager.call_tool(
                            'filesystem',
                            'read_file',
                            {'path': file_path},
                            session_id
                        )
                        results.append(result)
            
            # If no specific tools matched, try listing available tools
            if not results:
                for server_name in client_manager.servers.keys():
                    try:
                        tools = await client_manager.get_available_tools(server_name)
                        if tools:
                            results.append({
                                'server': server_name,
                                'available_tools': [
                                    {'name': tool.name, 'description': tool.description}
                                    for tool in tools
                                ]
                            })
                    except Exception as e:
                        logger.error(f"Error getting tools from {server_name}: {e}")
            
            return results
            
        except Exception as e:
            logger.error(f"Error processing query: {e}")
            return [{'error': str(e)}]
    
    # Run async function
    loop = asyncio.new_event_loop()
    asyncio.set_event_loop(loop)
    try:
        results = loop.run_until_complete(process_query())
        
        # Add results to conversation
        client_manager.add_to_conversation(session_id, {
            'type': 'assistant_response',
            'content': results
        })
        
        return jsonify({'results': results})
    finally:
        loop.close()

@app.route('/api/sessions/<session_id>/call-tool', methods=['POST'])
def call_tool_endpoint(session_id):
    """Manually call a specific tool"""
    session = client_manager.get_session(session_id)
    if not session:
        return jsonify({'error': 'Session not found'}), 404
    
    data = request.json
    server_name = data.get('server')
    tool_name = data.get('tool')
    arguments = data.get('arguments', {})
    
    if not server_name or not tool_name:
        return jsonify({'error': 'Server and tool name are required'}), 400
    
    async def call_tool_async():
        return await client_manager.call_tool(server_name, tool_name, arguments, session_id)
    
    # Run async function
    loop = asyncio.new_event_loop()
    asyncio.set_event_loop(loop)
    try:
        result = loop.run_until_complete(call_tool_async())
        return jsonify({'result': result})
    finally:
        loop.close()

@app.route('/api/sessions/<session_id>/events')
def stream_events(session_id):
    """SSE endpoint for real-time updates"""
    session = client_manager.get_session(session_id)
    if not session:
        return jsonify({'error': 'Session not found'}), 404
    
    def event_stream():
        try:
            while session_id in client_manager.event_queues:
                try:
                    event = client_manager.event_queues[session_id].get(timeout=30)
                    yield f"data: {json.dumps(event)}\n\n"
                except Empty:
                    # Send heartbeat
                    yield f"data: {json.dumps({'type': 'heartbeat', 'timestamp': datetime.now().isoformat()})}\n\n"
                except Exception as e:
                    logger.error(f"Error in event stream: {e}")
                    break
        except Exception as e:
            logger.error(f"Event stream error: {e}")
    
    return Response(
        event_stream(),
        mimetype='text/event-stream',
        headers={
            'Cache-Control': 'no-cache',
            'Connection': 'keep-alive',
            'Access-Control-Allow-Origin': '*'
        }
    )

@app.route('/api/sessions/<session_id>/history', methods=['GET'])
def get_session_history(session_id):
    """Get session conversation history"""
    session = client_manager.get_session(session_id)
    if not session:
        return jsonify({'error': 'Session not found'}), 404
    
    return jsonify({
        'conversation_history': session.conversation_history,
        'tool_calls': session.tool_calls
    })

@app.route('/health', methods=['GET'])
def health_check():
    """Health check endpoint"""
    return jsonify({
        'status': 'healthy',
        'active_sessions': len(client_manager.sessions),
        'connected_servers': len(client_manager.clients)
    })

if __name__ == '__main__':
    print("Starting MCP Client Flask Server...")
    print("Available endpoints:")
    print("  POST /api/sessions - Create new session")
    print("  GET  /api/sessions/<id> - Get session info")
    print("  GET  /api/servers - List servers")
    print("  GET  /api/servers/<name>/tools - List tools")
    print("  POST /api/sessions/<id>/query - Process query")
    print("  POST /api/sessions/<id>/call-tool - Call specific tool")
    print("  GET  /api/sessions/<id>/events - SSE event stream")
    print("  GET  /api/sessions/<id>/history - Get session history")
    print("  GET  /health - Health check")
    
    app.run(host='0.0.0.0', port=5000, debug=True, threaded=True)
